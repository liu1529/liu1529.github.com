<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>iOS Layers &#8211; 我的博客</title>
<meta name="description" content="欢迎来到我的博客">
<meta name="keywords" content="iOS, Layer">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS Layers">
<meta property="og:description" content="欢迎来到我的博客">
<meta property="og:url" content="/iOS-Layer/">
<meta property="og:site_name" content="我的博客">





<link rel="canonical" href="/iOS-Layer/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="我的博客 Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.min.css">
<!-- Webfonts -->
<script src="//use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body id="post">

<div class="navigation-wrapper">
	<nav role="navigation" id="site-nav" class="animated drop">
	    <ul>
	        
			<li>
				
					<a href="/about/">About</a>
				 
			</li>
	        
			<li>
				
					<a href="/articles/">Articles</a>
				 
			</li>
	        
			<li>
				
					<a href="/tags/">Tags</a>
				 
			</li>
	        
	        <li><a href="/feed.xml" title="Atom/RSS feed"><i class="icon-rss"></i> Feed</a></li>
	        <li class="dosearch"><i class="icon-search"></i> Search</li>
	    </ul>
	</nav>
</div><!-- /.navigation-wrapper -->

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->

<div class="search-wrapper">
	<div class="search-form">
		<input type="text" class="search-field" placeholder="Search...">
		<i class="icon-remove-sign icon-2x"></i>
		<ul class="search-results post-list"></ul><!-- /.search-results -->
	</div><!-- /.search-form -->
</div><!-- ./search-wrapper -->

<header class="masthead">
	<div class="wrap">
        
    		<a href="/" class="site-logo" rel="home" title="我的博客"><img src="/images/site-logo.png" width="200" height="200" alt="我的博客 logo" class="animated fadeInUp"></a>
        
        <h1 class="site-title animated fadeIn"><a href="/">我的博客</a></h1>
		<h2 class="site-description animated fadeIn" itemprop="description">欢迎来到我的博客</h2>
	</div>
</header><!-- /.masthead -->


<div id="main" role="main">
  <article class="hentry">
    
    <div class="entry-wrapper">
      <header class="entry-header">
        <span class="entry-tags"><a href="/tags/#iOS" title="Pages tagged iOS">iOS</a>&nbsp;&bull;&nbsp;<a href="/tags/#Layer" title="Pages tagged Layer">Layer</a></span>
        
          <h1 class="entry-title">iOS Layers</h1>
        
      </header>
      <footer class="entry-meta">
        <img src="/images/bio-photo.jpg" alt="liu1529 photo" class="author-photo">
        <span class="author vcard">By <span class="fn"><a href="/about/" title="About liu1529">liu1529</a></span></span>
        <span class="entry-date date published"><time datetime="2014-10-20T00:00:00+08:00"><i class="icon-calendar-empty"></i> October 20, 2014</time></span>
        
        <span class="entry-comments"><i class="icon-comment-alt"></i> <a href="#disqus_thread">Comment</a></span>
        <span><a href="/iOS-Layer/" rel="bookmark" title="iOS Layers"><i class="icon-link"></i> Permalink</a></span>
        
      </footer>
      <div class="entry-content">
        <p>UIView有一个搭档叫CALayer，UIView实际上不直接绘制在屏幕上，它绘制在它的layer上面，layer再绘制在屏幕上面。view不会每次都重新绘制，它会缓存绘制
（存储的是bitmap），它缓存的实际上就是layer。view的graphic context实际上是layer的graphic context。layer有如下功能：</p>

<ul>
  <li>
    <p>layer有属性会影响绘制</p>
  </li>
  <li>
    <p>多个layers可以和单个view组合</p>
  </li>
  <li>
    <p>layer是动画的基础</p>
  </li>
</ul>

<h1 id="view-layer">View 和layer</h1>

<p>一个UIView有一个CALayer，可以使用view的layer属性访问。layer没有view属性，但是view是layer的
delegate，这个layer被称为view的”优先layer(underlying layer)”。</p>

<blockquote>
  <p>layer的delegate属性可以被设置，但是永远不要设置underlying layer的delegate属性</p>
</blockquote>

<p>当你子类化UIView，想要子类化的layer成为view的underlying layer，你可以重写UIView的<code>layerClass</code>
方法：</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">+</span> <span class="p">(</span><span class="kt">Class</span><span class="p">)</span> <span class="nf">layerClass</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">CompassLayer</span> <span class="k">class</span><span class="p">];</span>
<span class="p">}</span></code></pre></div>

<p>layer扮演着view所有绘制的功能，如果view绘制，layer会同样绘制。view是layer的delegate，访问view
的属性通常仅仅是访问layer的属性。例如，你设置view的backgroundColor，实际上你设置的是layer的
backgroundColor，如果你直接设置layer的backgroundColor，view的backgroundColor也会同样被设置。</p>

<p>view在它的layer中绘制，layer缓存这些绘制为一个图片。layer接下来可以被操作，在view不被重新绘制的前提下，
可以改变view的显示。</p>

<h1 id="layers--sublayers">layers 和 sublayers</h1>

<p>一个layer可以有多个sublayers，view的子view的underlying layer是view的underlying layer的子layer。</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="bp">CALayer</span><span class="o">*</span> <span class="n">lay1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CALayer</span> <span class="n">new</span><span class="p">];</span>
<span class="n">lay1</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">113</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">194</span><span class="p">);</span>
<span class="n">lay1</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span>
        <span class="p">[[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mi">1</span> <span class="nl">green</span><span class="p">:</span><span class="mf">.4</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">1</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="bp">CGColor</span><span class="p">];</span>
<span class="p">[</span><span class="n">mainview</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">lay1</span><span class="p">];</span>

<span class="bp">CALayer</span><span class="o">*</span> <span class="n">lay2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CALayer</span> <span class="n">new</span><span class="p">];</span>
<span class="n">lay2</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span>
    <span class="p">[[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mf">.5</span> <span class="nl">green</span><span class="p">:</span><span class="mi">1</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="bp">CGColor</span><span class="p">];</span>
<span class="n">lay2</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">41</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">194</span><span class="p">);</span>
<span class="p">[</span><span class="n">lay1</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">lay2</span><span class="p">];</span>

<span class="bp">UIImageView</span><span class="o">*</span> <span class="n">iv</span> <span class="o">=</span>
	<span class="p">[[</span><span class="bp">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;smiley&quot;</span><span class="p">]];</span>
<span class="bp">CGRect</span> <span class="n">r</span> <span class="o">=</span> <span class="n">iv</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
<span class="n">r</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">);</span>
<span class="n">iv</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
<span class="p">[</span><span class="n">mainview</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">iv</span><span class="p">];</span>

<span class="bp">CALayer</span><span class="o">*</span> <span class="n">lay3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CALayer</span> <span class="n">new</span><span class="p">];</span>
<span class="n">lay3</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span>
        <span class="p">[[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mi">1</span> <span class="nl">green</span><span class="p">:</span><span class="mi">0</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="bp">CGColor</span><span class="p">];</span>
<span class="n">lay3</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">43</span><span class="p">,</span> <span class="mi">197</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">230</span><span class="p">);</span>
<span class="p">[</span><span class="n">mainview</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">lay3</span><span class="p">];</span></code></pre></div>

<p>layer的子layer显示是否超过父layer的边界，由layer的masksToBounds属性决定，这个属性同view的
clipsToBounds属性作用一样。</p>

<h2 id="layer">管理layer的层次结构</h2>

<p>layer同view一样也有superlayer和sublayers属性，可以通过下面的方法管理layer的层次结构：</p>

<ul>
  <li>addSublayer:</li>
  <li>insertSublayer:atIndex:</li>
  <li>insertSublayer:below:</li>
  <li>insertSublayer:above:</li>
  <li>replaceSublayer:with:</li>
  <li>removeFromSuperlayer</li>
</ul>

<p>不像view的subviews属性，layer的sublayers属性是可写的，你可以一次性删除和改写它的所有sublayers。
layer还有一个属性<code>zPosition</code>来决定layer的顺序，zPostion默认为0。</p>

<p>layer同样提供了如下方法，用于转换在同一层次结构中两个layer的坐标系</p>

<ul>
  <li>convertPoint:fromLayer:,convertPoint:toLayer: </li>
  <li>convertRect:fromLayer:,convertRect:toLayer:</li>
</ul>

<h2 id="sublayer">定位sublayer</h2>

<p>layer的内部坐标系同view一样，使用bounds表示。但是layer在其superlayer的位置，并不像view那样
使用center表示，它取决于两个属性，position和anchorPoint。想象layer是钉在其superlayer上面，
那么需要同时知道图钉在layer和superlayer的位置。</p>

<ul>
  <li>
    <p>position
在superlayer坐标系中的位置</p>
  </li>
  <li>
    <p>anchorPoint
position相对于layer自己的bounds的位置。它表示当前位置和自己宽度和高度的比值，如{0,0}表示在
layer的左上角，{1,1}表示在layer的右下角。</p>
  </li>
</ul>

<p>如果anchorPoint等于{0.5,0.5}(默认)，那么position相当于view的center。layer的position和
anchorPoint是相互独立的，改变一个并不会改变另一个。</p>

<p>layer的frame仅仅是一个计算出来的数据；当你读取frame时，layer通过计算bounds、position和anchorPoint
得出相应的frame；当你设置frame时，同时会设置bounds和position。</p>

<blockquote>
  <p>在代码中创建layer时，它的frame和bounds都是{0,0}、{0,0}。你必须设置正确的非零值，这个layer
才会显示出来。</p>
</blockquote>

<h2 id="cascrolllayer">CAScrollLayer</h2>

<p>当你想要移动一个layer的bounds原点后，它的sublayers也跟着一起移动时，你可以使用CALayer的子类
CAScrollLayer(不像它的名字，CAScrollLayer不提供scroll界面)。默认情况下，CAScrollLayer的
masksToBounds属性为YES，因此你不能看见所有超出bounds的界面。(你也可以设置masksToBounds为
NO，但是会有奇怪的事情发生，可能不能满足你的要求)。</p>

<p>你可以移动CAScrollLayer的bounds，也可以移动其任意深度的sublayer</p>

<p>移动CAScrollLayer:</p>

<ul>
  <li>
    <p>scrollToPoint：
改变CAScrollLayer的原点到指定点</p>
  </li>
  <li>
    <p>scrollToRect：
最小改变CAScrollLayer的原点，使指定的范围可见</p>
  </li>
</ul>

<p>移动sublayers：</p>

<ul>
  <li>
    <p>scrollPoint：
改变CAScrollLayer的原点，使sublayer的指定点在CAScrollLayer的左上角</p>
  </li>
  <li>
    <p>scrollRectToVisible：
改变CAScrollLayer的原点，使sublayer的bounds的指定范围在CAScrollLayer的bounds范围内。
你可以访问sublayer的visibleRect属性，现在它在CAScrollLayer的bounds范围内。</p>
  </li>
</ul>

<h2 id="sublayers">sublayers的布局</h2>

<p>view的层次结构实际上是layer的层次结构，view在superview中的位置，实际上是layer在其superlayer
中的位置。view可以通过autoresizingMask或者constraint实现自动布局，因此，如果layer是view的
underlying layer那么它也可以。否则，不是underlying layer就不能实现自动布局，只能在代码中
手动调整位置。</p>

<p>当一个layer需要布局时，不管是它bounds发生变化还是你调用<code>setNeedsLayout</code>,你可以通过下列方法
中的任意一种实现：</p>

<ul>
  <li>重写CALayer子类中的<code>layoutSublayers</code>方法</li>
  <li>在layer的delegate中实现<code>layoutSublayersOfLayer:</code>方法</li>
</ul>

<p>当手动布局时，你可能需要标识出每个sublayers，以方便后面引用。在Layer中没有<code>viewWithTag:</code>类似
的方法，你可以使用key-value编程方法，这将后面会介绍。</p>

<p>对于view的underlying layer，<code>layoutSublayers</code>和<code>layoutSublayersOfLayer</code>在view的
<code>layoutSubviews</code>后调用。如果使用自动布局，你必须调用super，而且这些方法可能调用多次，如果你
想要只调用一次的方法，请使用<code>layoutSubviews</code>。</p>

<h1 id="layer-1">在layer中绘制</h1>

<p>如果<code>drawRect:</code>实现，那么view在它的underlying layer中绘制。下面介绍怎么在其他layer中绘制。</p>

<p>最简单的方法，是设置layer的contents属性，它类似于UIImageView的image属性。contents接受一个
CGImageRef或nil，contents的类型是id，而CGImageRef是一个对象，因此，在赋值时你必须强制转换。</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="bp">CALayer</span><span class="o">*</span> <span class="n">lay4</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CALayer</span> <span class="n">new</span><span class="p">];</span>
<span class="bp">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;smiley&quot;</span><span class="p">];</span>
<span class="bp">CGRect</span> <span class="n">r</span> <span class="o">=</span> <span class="n">lay4</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
<span class="n">r</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">);</span>
<span class="n">r</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">im</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="n">lay4</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
<span class="n">lay4</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">im</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">;</span>
<span class="p">[</span><span class="n">mainview</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">lay4</span><span class="p">];</span></code></pre></div>

<blockquote>
  <p>设置layer的contents为UIImage，而不是CGImageRef，会导致图形不显示，但是不会提示任何错误</p>
</blockquote>

<p>layer有4个方法，用于绘制它的contents，在下列情况下会调用它们：</p>

<ul>
  <li>
    <p>如果layer的<code>needsDisplayOnBoundsChange</code>为NO（默认），除非你调用<code>setNeedsDisplay</code>或
<code>setNeedsDisplayInRect:</code>，layer才会重新绘制。</p>
  </li>
  <li>
    <p>如果layer的<code>needsDisplayOnBoundsChange</code>为YES，那么当layer的bounds变化时，layer会重新
绘制（相当于UIView的UIViewContentModeRedraw)。</p>
  </li>
</ul>

<p>下面有4个方法用于绘制，选择一个来实现（不要实现多个，会导致冲突）</p>

<ul>
  <li>subclass中的<code>display</code></li>
</ul>

<p>CALayer的子类可以重写<code>display</code>方法，这儿没有graphic context，因此这个方法仅仅用于设置contents属性。</p>

<ul>
  <li>delegate中<code>displayLayer:</code></li>
</ul>

<p>你可以设置CALayer的delegate属性，然后在其delegate中实现<code>displayLayer:</code>，这儿也没有graphic context，
因此你仅能设置contents属性。</p>

<ul>
  <li>subclass中<code>drawInContext:</code></li>
</ul>

<p>CALayer的子类可以重写<code>drawInContext:</code>方法，提供的graphic context你可以直接用于绘制，但不会
使其为当前context。</p>

<ul>
  <li>delegate中的<code>drawLayer:inContext:</code></li>
</ul>

<p>你可以设置CALayer的delegate属性，然后在其delegate中实现<code>drawLayer:inContext:</code>，提供的
graphic context你可以直接用于绘制，但不会使其为当前context。</p>

<p>layer有一个<code>contentScale</code>属性，如果layer被CoCoa管理，且它有contents，系统将会设置正确的
<code>contentSacle</code>。例如，UIView实现了<code>drawRect:</code>方法，在一个double-resolution设备中，它的
underlying layer的<code>contentScale</code>为2。你自己创建的layer中，没有自动为你设置好<code>contentScale</code>，
你必须正确它的值，否则会导致显示出错。你可以通过<code>[UIScreen mainScreen].scale</code>获得正确的值。</p>

<p>下面的属性对layer的显示影响很大，初学者很容易混淆它们。</p>

<ul>
  <li>
    <p><code>backgroundColor</code>：把它和layer的绘制分开考虑，它相当layer的绘制的背景。它等于view的
<code>backgroundColor</code>（如果它是view的underlying layer，那么它就是view<code>backgroundColor</code>），
设置它会立即生效。</p>
  </li>
  <li>
    <p><code>opaque</code>：决定layer的graphic context是否为不透明。一个不透明的graphic context是黑色的，
你可以在黑色上面绘制，但是黑色任然在那儿。一个透明的graphic context是完全透明的。改变layer的
opaque只有在重新绘制layer时才会生效。view的underlying layer的<code>opaque</code>属性和view的<code>opaque</code>
属性是完全独立的，它们是完全不同的。</p>
  </li>
  <li>
    <p><code>opacity</code>：影响所有的layer和其sublayers的透明度。它等于view的<code>alpha</code>（如果他是view的
underlying layer，那么它就是view的<code>alpha</code>）。它分别影响着background color和layer的contents
的透明度，改变它立即生效。</p>
  </li>
</ul>

<h2 id="viewunderlying-layer">view的underlying layer自动重新绘制</h2>

<p>一个layer不会自动重新绘制，除非<code>needsDisplayOnBoundsChange</code>为YES且bounds发生改变，但是view
会。例如，当你发送<code>setNeedsDisplay</code>时，view会重新绘制，但是如果你的view没有实现<code>drawRect:</code>，那么
它不会给underlying layer发送<code>setNeedsDisplay</code>。因此，当你直接在view的underlying layer中
执行所有绘制时，你想要underlying layer自动重新绘制，你应该实现<code>darwRect:</code>方法，即使这个方法
什么都不做。(这不会影响到underlying layer的sublayers)。</p>

<h2 id="contents">contents的大小和位置</h2>

<p>layer的context被缓存为一个bitmap，就像image一样对待。</p>

<ul>
  <li>
    <p>如果contents来自于直接设置layer的属性contents，那么缓存的就是那张图片，大小就是图片的大小。</p>
  </li>
  <li>
    <p>如果contents来自于graphic context的绘制（drawInContext:, drawLayer:inContext:），那么
缓存的就是整个graphic context，大小是layer在绘制时的大小。</p>
  </li>
</ul>

<p>下面的这些layer属性影响着缓存的contents怎么显示：</p>

<ul>
  <li>
    <p>contentsGravity：
这个相当于UIView的<code>contentMode</code>属性。</p>
  </li>
  <li>
    <p>contentsRect：
决定哪些部分能被显示，默认是{{0,0},{1,1}}表示整个都可以被显示。也可以用于按比例缩小contents，设置
一个更大的区域如{{-0.5,-0.5},{1.5,1.5}}，但是任何contents的边界会被扩充到layer的边界（为了保护
这些区域，应所有超过contents边界的区域都为空）。</p>
  </li>
  <li>
    <p>contentsCenter：
一个CGRect，和resizable image的缩放行为相同。将一个contentsRect分为9个区域，中间的contentsCenter
区域向两边缩放，4边的区域向一个方向缩放，4角的区域不缩放。</p>
  </li>
</ul>

<p>如果layer的contents来自于直接在graphic context绘制，那么layer的contentsGravity没有影响，
因为graphic context的大小刚好是layer的大小。但是如果layer的contentsRect不等于{{0,0},{1,1}}，
那么contentsGravity会有影响。</p>

<p>再次重申，当layer的contents来自于直接在graphic context绘制，layer大小改变时，如果layer被
要求重新显示，layer会被重新执行绘制以保证contents的大小刚好为layer的大小。但如果layer的
<code>needsDisplayOnBoundsChange</code>为NO，那么当layer的大小改变时，它不会被重新绘制，它将使用缓存
的contents，这时contentsGravity就会起作用。</p>

<p>layer的<code>maskToBounds</code>属性对它的sublayers有同样的影响。如果为NO，即使contents超过layer
（取决于layer的<code>contentsGravity</code>和<code>contentsRect</code>）也会显示整个contents。如果为YES，只有
在layer的bounds范围内的才会显示。</p>

<h2 id="layer-2">layer的内置类型</h2>

<ul>
  <li>CATextLayer</li>
</ul>

<p>CATextLayer有一个<code>string</code>属性，它会绘制其<code>string</code>属性。默认情况下，文本的颜色<code>foregroundColor</code>
是白色，这可能不是你想要的颜色。<code>string</code>属性和layer的<code>contents</code>属性不相容，它会绘制其中的一个，但
不会两个都绘制，所以通常不应该设置CATextLayer的<code>contents</code>属性。</p>

<ul>
  <li>CAShapeLayer</li>
</ul>

<p>CAShapeLayer有一个类型为CGPath的<code>path</code>属性，它会使用<code>fillColor</code>填充或使用<code>strokeColor</code>画出
这个path。CAShapeLayer也可以使用<code>contents</code>属性，图形会显示在contents图形上面，但是没有方法指定
它们的混合模式。</p>

<ul>
  <li>CAGradientLayer</li>
</ul>

<p>CAGradientLayer将背景(background)转换为一个简单的线性渐变。就像Core Graphic中渐变一样，你需要
指定使用数组(NSArray)指定渐变位置和颜色（需要的颜色是CGColor，因此你需要强制转换为id类型才能加入数组）。
CAGradientLayer的<code>contents</code>不会被显示。</p>

<h1 id="transform">Transform</h1>

<p>最简单的变换是二维变换，你可以使用<code>affineTransform</code>进行二维变换，它是一个CGAffineTransform类型，同
view的transform相同，它围绕着<code>anchorPoint</code>变换。</p>

<p>完整的变换是三维变换，包含x、y、z轴。layer并不能给你逼真的三维透视图，你可以使用OpenGL达到这个目的。
三维变换扩展了<code>anchorPoint</code>，加入<code>anchorPointZ</code>属性以用于支持z轴变换。三维变换在apple中被称为
CATransform3D，它和CAAffineTransform相似，只是在其基础上加入了z轴。</p>

<h2 id="depth">Depth</h2>

<h1 id="section">阴影，边框，面罩</h1>

<p>CALayer有很多属性影响着绘制，因为这些属性也可以在view的underlying layer中应用，所以它们也影响着view。</p>

<p>CALayer可以有阴影效果，通过<code>shadowColor</code>，<code>shadowOpacity</code>，<code>shadowRadius</code>，<code>shadowOffset</code>属性
配置。阴影会添加到图形非透明的地方，你可以自己定义图形然后将这个图片赋值给CGPath的<code>shadowPath</code>属性
以提高性能。</p>

<p>CALayer可以通过<code>borderWidth</code>和<code>borderColor</code>定义边框。通过设置<code>cornerRadius</code>可以让layer有圆角矩形
效果。</p>

<h1 id="layer-">layer 效率</h1>

<h1 id="layerkey-value">layer和key-value编程</h1>

<p>layer的所有属性都可以通过key-value编程来访问。因此设置layer的mask：</p>

<pre><code>layer.mask = mask;
</code></pre>

<p>也可以这样书写：</p>

<pre><code>[layer setValue:mask forKey:@"mask"]
</code></pre>

<p>而且，CATransform3D和CGAffineTransform的值可以通过key-value编程得到扩充访问。如：</p>

<pre><code>self.rotationLayer.transform = CGTransform3DMakeRotation(M_PI/4.0, 0, 1, 0);
</code></pre>

<p>可以写成：</p>

<pre><code>[self.rotationLayer setValue:@(M_PI/4.0) forKeyPath:@"transform.rotation.y"]
</code></pre>

<p>此外，你可以将CALayer想象为一个NSDictionary，你可以设置它的任意key和value。比如，当你手动布局layer
时，你需要分别每个sublayers。你可以这样使用：</p>

<pre><code>[myLayer1 setValue:@"layer1" forKey:@"name"];
[myLayer2 setValue:@"layer2" forKey:@"name"];
</code></pre>

<p>layer并没有<code>name</code>属性，但是你这样使用，用于辨识每个sublayers。</p>


        <div id="disqus_thread"></div><!-- /#disqus_thread -->
      </div><!-- /.entry-content -->
    </div><!-- /.entry-wrapper -->
    <nav class="pagination" role="navigation">
      
        <a href="/iOS-Drawing/" class="btn" title="iOS Drawing">Previous article</a>
      
      
        <a href="/iOS-Animation/" class="btn" title="iOS Animation">Next article</a>
      
    </nav><!-- /.pagination -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2014 liu1529. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/so-simple/">So Simple Theme</a>.</span>
<div class="social-icons">
	
	
	
	
	
	
	
	
	
</div><!-- /.social-icons -->
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Jekyll Simple Search option -->
<script>
  $(document).ready(function() {
      $('.search-field').simpleJekyllSearch({
          jsonFile : '/search.json',
          searchResults : '.search-results',
          template : '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>',
          noResults: '<p>Nothing found.</p>'
        });
  });

  (function( $, window, undefined ) {
    
     var bs = {
          close: $(".icon-remove-sign"),
          searchform: $(".search-form"),
          canvas: $("body"),
          dothis: $('.dosearch')
      };
    
    bs.dothis.on('click', function() {
      $('.search-wrapper').css({ display: "block" });
      bs.searchform.toggleClass('active');
      bs.searchform.find('input').focus();
      bs.canvas.toggleClass('search-overlay');
    });
    
      bs.close.on('click', function() {
        $('.search-wrapper').removeAttr( 'style' );
        bs.searchform.toggleClass('active');
        bs.canvas.removeClass('search-overlay');
    });
  })( jQuery, window );
</script>


<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'liu1529'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>	        

</body>
</html>
