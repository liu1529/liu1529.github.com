---
title: iOS UIView
layout: post
tags: [iOS,UIView]
comments: true
---

iOS里面可以说UIView是最重要的类之一，所有界面上的控件都是UIView的子类，UIView继承自UIResponder，UIResponder负责处理事件，而
UIResponder继承自NSObject。NSObject是Cocoa里面绝大部分类的根类。view hierarchy 是view最重要的组织形式，一个view可以拥有subviews，
而一个subview也有一个superview。view hierarchy使view一起出现和移动，当一个view移动时，它的所有subviews也一起移动；当一个view
被删除后，它的所有subviews也被一起删除。

# The Window

view hierarchy的顶层元素是app的window，它是UIWindow的一个实例，并继承自UIView。app应该只有一个main window，而且一个屏幕只能
有一个window，它是界面上有效view的最终superview。window必须将设备的屏幕填充满：

{% highlight objc %}
UIWindow *w = [[UIWindow alloc] initWithFrame:[[UIScreen maniScreen] bounds]];

{% endhighlight %}

* App 使用 main storyboard


如果你的app使用main storyboard，那么UIApplicationMain会自动实例化一个正确的
UIWindow并将它赋值给app delegate的window属性，然后它会实例化storyboard的initial
view controller并将它赋值给window的rootViewController属性。这些都在app调用
`application:didFinnishLaunchingWithOptions`之前完成。
最后，UIApplicationMain会调用`makeKeyAndVisible`来显示app的界面，这些在调用`application:didFinnishLaunchingWithOptions`
之后完成。

如果你想子类化window时，你必须在AppDelegate.m文件里面重写window属性的getter函数:

{% highlight objc %}
- (UIWindow*) window {
UIWindow* w = self->_window;
if (!w) {
    w = [[MyWindow alloc] initWithFrame:
    [[UIScreen mainScreen] bounds]];
    self->_window = w;
}
return w;
}

{% endhighlight %}

* App 不使用 main storyboard


如果你的app没有main storyboard，通常使用代码来完成：

{% highlight objc %}
self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
// Override point for customization after application launch.
self.window.backgroundColor = [UIColor whiteColor];
[self.window makeKeyAndVisible];

{% endhighlight %}


如果你想引用window属性，可以使用application的delegate中的window属性

`UIWindow* w = [[[UIApplication sharedApplication] delegate] window]`

# SuperView 和 SubView

* 如果一个view在它的superview上移除或移动，它的所有subview也一起移除或移动。
* 一个view的透明度将会被它的subview继承。
* 如果view的subview的范围超出view的范围，可以不显示subview超出范围部分，这被称为clipping，通过clipsToBounds属性设置。
* superview负责管理它的subview，当一个subview不再属于它的superview或superview本身被释放时，superview负责释放它的subview。
* 当view的尺寸被改变时，它的subview也可以自动改变。

一个UIView有superview属性和subviews属性，`isDescendantOfView:`可以检测一个view是否
是另一个view的subview，不管深度有多深。如果你想引用一个特殊的view，你可以通过outlet，
或通过设置view的tag属性，然后使用`viewWithTag:`方法获得。

`addSubview:`方法使一个view成为另一个的subview，`removeFromSuperview`方法将一个view
从它的superview的view hierarchy中移除。记住，一个view从它superview移除后，view
将会被释放，如果你还想使用它，你必须先保持(retain)它，通常通过设置属性的retain来完成。

当这些改变发生时，会发送事件通知，你需要通过子类化来重写这些事件，以处理事件。

* `didAddSubview:` `willRemoveSubview:`
* `didMoveToSuperview:` `willMoveToSuperview:` 
* `didMoveToWindow:` `willMoveToWindow:`

`addSubview`会将view放在superview的最前端，你也可以通过下面的方法，将view插入到view
hierarchy的任意位置：

* `insertSubview:atIndex:`
* `insertSubview:belowSubvie:` `insertSubview:aboveSubview:`
* `exchangeSubviewAtIndex:withSubviewAtIndex:`
* `bringSubviewToFont:` `sendSubviewToBack:`

你可以通过下面的方法，删除所有subview。

{% highlight objc %}

for(UIView *v in view.subviews)
    [v removeFromSuperview];

{% endhighlight %}

或

    [view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];


# 隐藏和透明

通过设置UIView的属性hidden来隐藏view，当view隐藏后通常它不会再接收事件。

通过设置backgroundColor属性来设置view的背景色，当backgroundColor的属性为nil时，
它拥有一个透明背景。当它的属性为nil时，它可以作为其他views的superview，这样可以使
这些views在同一个view hierarchy中。

通过设置alpha属性，可以改变view的透明度（1.0表示不透明，0.0表示完全透明）。这将会
影响它的subviews，如果superview的alpha为0.5，那么它的subviews的alpha都不会超过0.5。
（更复杂的是颜色也有alpha属性，例如，一个view的alpha为1.0，它也可以拥有一个透明背景，
因为，它的backgroundColor的alpha小于1.0）。一个view完全透明，相当于设置hidden为YES，
它和它的subviews都会不可见，通常也不会在接收事件。

view的alpha属性同样会影响它背景色的可见度和它内容的可见度。例如，如果一个view的alpha
小于1，它显示一个图像且有背景色，背景色将会透过图像显示出来（view后面的任何东西都会
穿透显示）。

view的opaque属性，不会影响view透明度，它对绘制（drawing）系统有影响。当一个view
完全填充它的边界范围，且它的opaque为YES，且alpha属性为1.0，那么提高绘制系统的性能。

# Frame

view的frame属性，表示view在其superview坐标系中的位置和大小。坐标原点在左上角，
向右为x轴，向下为y轴。

## Bounds and Center

bounds属性表示view在自己的坐标系中的位置和大小，`CGRectInset`可以很方便的
将一个view插入到另一个view中：

    UIView *v2 = [[UIView alloc] initWithFrame:CGRectInset(v1.bounds, 10, 10)];

改变view的bounds会影响它的frame，同样改变frame会影响bounds，但是改变bounds不会影响
view的center属性。center属性就像frame属性一样，代表view在其superview坐标系中位置，
但是它是bounds的中心位置，它的值就像如图下面表示：

    CGPoint center = CGPointMake(CGRectGetMidX(theView.bounds), 
                                 CGRectGetMidY(theView.bounds));




